// Code generated by protoc-gen-go. DO NOT EDIT.
// source: onnx.proto3

package ir

import (
	fmt "fmt"
	math "math"

	proto "github.com/golang/protobuf/proto"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Versioning
//
// ONNX versioning is specified in docs/IR.md and elaborated on in docs/Versioning.md
//
// To be compatible with both proto2 and proto3, we will use a version number
// that is not defined by the default value but an explicit enum number.
type Version int32

const (
	// proto3 requires the first enum value to be zero.
	// We add this just to appease the compiler.
	Version__START_VERSION Version = 0
	// The version field is always serialized and we will use it to store the
	// version that the  graph is generated from. This helps us set up version
	// control.
	// For the IR, we are using simple numbers starting with with 0x00000001,
	// which was the version we published on Oct 10, 2017.
	Version_IR_VERSION_2017_10_10 Version = 1
	// IR_VERSION 2 published on Oct 30, 2017
	// - Added type discriminator to AttributeProto to support proto3 users
	Version_IR_VERSION_2017_10_30 Version = 2
	// IR VERSION 3 published on Nov 3, 2017
	// - For operator versioning:
	//    - Added new message OperatorSetIdProto
	//    - Added opset_import in ModelProto
	// - For vendor extensions, added domain in NodeProto
	Version_IR_VERSION Version = 3
)

var Version_name = map[int32]string{
	0: "_START_VERSION",
	1: "IR_VERSION_2017_10_10",
	2: "IR_VERSION_2017_10_30",
	3: "IR_VERSION",
}

var Version_value = map[string]int32{
	"_START_VERSION":        0,
	"IR_VERSION_2017_10_10": 1,
	"IR_VERSION_2017_10_30": 2,
	"IR_VERSION":            3,
}

func (x Version) String() string {
	return proto.EnumName(Version_name, int32(x))
}

func (Version) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d0206993eefcdc9e, []int{0}
}

// Note: this enum is structurally identical to the OpSchema::AttrType
// enum defined in schema.h.  If you rev one, you likely need to rev the other.
type AttributeProto_AttributeType int32

const (
	AttributeProto_UNDEFINED AttributeProto_AttributeType = 0
	AttributeProto_FLOAT     AttributeProto_AttributeType = 1
	AttributeProto_INT       AttributeProto_AttributeType = 2
	AttributeProto_STRING    AttributeProto_AttributeType = 3
	AttributeProto_TENSOR    AttributeProto_AttributeType = 4
	AttributeProto_GRAPH     AttributeProto_AttributeType = 5
	AttributeProto_FLOATS    AttributeProto_AttributeType = 6
	AttributeProto_INTS      AttributeProto_AttributeType = 7
	AttributeProto_STRINGS   AttributeProto_AttributeType = 8
	AttributeProto_TENSORS   AttributeProto_AttributeType = 9
	AttributeProto_GRAPHS    AttributeProto_AttributeType = 10
)

var AttributeProto_AttributeType_name = map[int32]string{
	0:  "UNDEFINED",
	1:  "FLOAT",
	2:  "INT",
	3:  "STRING",
	4:  "TENSOR",
	5:  "GRAPH",
	6:  "FLOATS",
	7:  "INTS",
	8:  "STRINGS",
	9:  "TENSORS",
	10: "GRAPHS",
}

var AttributeProto_AttributeType_value = map[string]int32{
	"UNDEFINED": 0,
	"FLOAT":     1,
	"INT":       2,
	"STRING":    3,
	"TENSOR":    4,
	"GRAPH":     5,
	"FLOATS":    6,
	"INTS":      7,
	"STRINGS":   8,
	"TENSORS":   9,
	"GRAPHS":    10,
}

func (x AttributeProto_AttributeType) String() string {
	return proto.EnumName(AttributeProto_AttributeType_name, int32(x))
}

func (AttributeProto_AttributeType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d0206993eefcdc9e, []int{0, 0}
}

type TensorProto_DataType int32

const (
	TensorProto_UNDEFINED TensorProto_DataType = 0
	// Basic types.
	TensorProto_FLOAT  TensorProto_DataType = 1
	TensorProto_UINT8  TensorProto_DataType = 2
	TensorProto_INT8   TensorProto_DataType = 3
	TensorProto_UINT16 TensorProto_DataType = 4
	TensorProto_INT16  TensorProto_DataType = 5
	TensorProto_INT32  TensorProto_DataType = 6
	TensorProto_INT64  TensorProto_DataType = 7
	TensorProto_STRING TensorProto_DataType = 8
	TensorProto_BOOL   TensorProto_DataType = 9
	// IEEE754 half-precision floating-point format (16 bits wide).
	// This format has 1 sign bit, 5 exponent bits, and 10 mantissa bits.
	TensorProto_FLOAT16    TensorProto_DataType = 10
	TensorProto_DOUBLE     TensorProto_DataType = 11
	TensorProto_UINT32     TensorProto_DataType = 12
	TensorProto_UINT64     TensorProto_DataType = 13
	TensorProto_COMPLEX64  TensorProto_DataType = 14
	TensorProto_COMPLEX128 TensorProto_DataType = 15
	// Non-IEEE floating-point format based on IEEE754 single-precision
	// floating-point number truncated to 16 bits.
	// This format has 1 sign bit, 8 exponent bits, and 7 mantissa bits.
	TensorProto_BFLOAT16 TensorProto_DataType = 16
)

var TensorProto_DataType_name = map[int32]string{
	0:  "UNDEFINED",
	1:  "FLOAT",
	2:  "UINT8",
	3:  "INT8",
	4:  "UINT16",
	5:  "INT16",
	6:  "INT32",
	7:  "INT64",
	8:  "STRING",
	9:  "BOOL",
	10: "FLOAT16",
	11: "DOUBLE",
	12: "UINT32",
	13: "UINT64",
	14: "COMPLEX64",
	15: "COMPLEX128",
	16: "BFLOAT16",
}

var TensorProto_DataType_value = map[string]int32{
	"UNDEFINED":  0,
	"FLOAT":      1,
	"UINT8":      2,
	"INT8":       3,
	"UINT16":     4,
	"INT16":      5,
	"INT32":      6,
	"INT64":      7,
	"STRING":     8,
	"BOOL":       9,
	"FLOAT16":    10,
	"DOUBLE":     11,
	"UINT32":     12,
	"UINT64":     13,
	"COMPLEX64":  14,
	"COMPLEX128": 15,
	"BFLOAT16":   16,
}

func (x TensorProto_DataType) String() string {
	return proto.EnumName(TensorProto_DataType_name, int32(x))
}

func (TensorProto_DataType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_d0206993eefcdc9e, []int{6, 0}
}

// Attributes
//
// A named attribute containing either singular float, integer, string, graph,
// and tensor values, or repeated float, integer, string, graph, and tensor values.
// An AttributeProto MUST contain the name field, and *only one* of the
// following content fields, effectively enforcing a C/C++ union equivalent.
type AttributeProto struct {
	// The name field MUST be present for this version of the IR.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// if ref_attr_name is not empty, ref_attr_name is the attribute name in parent function.
	// In this case, this AttributeProto does not contain data, and it's a reference of attribute
	// in parent scope.
	// NOTE: This should ONLY be used in function (sub-graph). It's invalid to be used in main graph.
	RefAttrName string `protobuf:"bytes,21,opt,name=ref_attr_name,json=refAttrName,proto3" json:"ref_attr_name,omitempty"`
	// A human-readable documentation for this attribute. Markdown is allowed.
	DocString string `protobuf:"bytes,13,opt,name=doc_string,json=docString,proto3" json:"doc_string,omitempty"`
	// The type field MUST be present for this version of the IR.
	// For 0.0.1 versions of the IR, this field was not defined, and
	// implementations needed to use has_field hueristics to determine
	// which value field was in use.  For IR_VERSION 0.0.2 or later, this
	// field MUST be set and match the f|i|s|t|... field in use.  This
	// change was made to accomodate proto3 implementations.
	Type AttributeProto_AttributeType `protobuf:"varint,20,opt,name=type,proto3,enum=onnx.AttributeProto_AttributeType" json:"type,omitempty"`
	// Exactly ONE of the following fields must be present for this version of the IR
	F                    float32        `protobuf:"fixed32,2,opt,name=f,proto3" json:"f,omitempty"`
	I                    int64          `protobuf:"varint,3,opt,name=i,proto3" json:"i,omitempty"`
	S                    []byte         `protobuf:"bytes,4,opt,name=s,proto3" json:"s,omitempty"`
	T                    *TensorProto   `protobuf:"bytes,5,opt,name=t,proto3" json:"t,omitempty"`
	G                    *GraphProto    `protobuf:"bytes,6,opt,name=g,proto3" json:"g,omitempty"`
	Floats               []float32      `protobuf:"fixed32,7,rep,packed,name=floats,proto3" json:"floats,omitempty"`
	Ints                 []int64        `protobuf:"varint,8,rep,packed,name=ints,proto3" json:"ints,omitempty"`
	Strings              [][]byte       `protobuf:"bytes,9,rep,name=strings,proto3" json:"strings,omitempty"`
	Tensors              []*TensorProto `protobuf:"bytes,10,rep,name=tensors,proto3" json:"tensors,omitempty"`
	Graphs               []*GraphProto  `protobuf:"bytes,11,rep,name=graphs,proto3" json:"graphs,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *AttributeProto) Reset()         { *m = AttributeProto{} }
func (m *AttributeProto) String() string { return proto.CompactTextString(m) }
func (*AttributeProto) ProtoMessage()    {}
func (*AttributeProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0206993eefcdc9e, []int{0}
}

func (m *AttributeProto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_AttributeProto.Unmarshal(m, b)
}
func (m *AttributeProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_AttributeProto.Marshal(b, m, deterministic)
}
func (m *AttributeProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AttributeProto.Merge(m, src)
}
func (m *AttributeProto) XXX_Size() int {
	return xxx_messageInfo_AttributeProto.Size(m)
}
func (m *AttributeProto) XXX_DiscardUnknown() {
	xxx_messageInfo_AttributeProto.DiscardUnknown(m)
}

var xxx_messageInfo_AttributeProto proto.InternalMessageInfo

func (m *AttributeProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *AttributeProto) GetRefAttrName() string {
	if m != nil {
		return m.RefAttrName
	}
	return ""
}

func (m *AttributeProto) GetDocString() string {
	if m != nil {
		return m.DocString
	}
	return ""
}

func (m *AttributeProto) GetType() AttributeProto_AttributeType {
	if m != nil {
		return m.Type
	}
	return AttributeProto_UNDEFINED
}

func (m *AttributeProto) GetF() float32 {
	if m != nil {
		return m.F
	}
	return 0
}

func (m *AttributeProto) GetI() int64 {
	if m != nil {
		return m.I
	}
	return 0
}

func (m *AttributeProto) GetS() []byte {
	if m != nil {
		return m.S
	}
	return nil
}

func (m *AttributeProto) GetT() *TensorProto {
	if m != nil {
		return m.T
	}
	return nil
}

func (m *AttributeProto) GetG() *GraphProto {
	if m != nil {
		return m.G
	}
	return nil
}

func (m *AttributeProto) GetFloats() []float32 {
	if m != nil {
		return m.Floats
	}
	return nil
}

func (m *AttributeProto) GetInts() []int64 {
	if m != nil {
		return m.Ints
	}
	return nil
}

func (m *AttributeProto) GetStrings() [][]byte {
	if m != nil {
		return m.Strings
	}
	return nil
}

func (m *AttributeProto) GetTensors() []*TensorProto {
	if m != nil {
		return m.Tensors
	}
	return nil
}

func (m *AttributeProto) GetGraphs() []*GraphProto {
	if m != nil {
		return m.Graphs
	}
	return nil
}

// Defines information on value, including the name, the type, and
// the shape of the value.
type ValueInfoProto struct {
	// This field MUST be present in this version of the IR.
	Name string `protobuf:"bytes,1,opt,name=name,proto3" json:"name,omitempty"`
	// This field MUST be present in this version of the IR.
	Type *TypeProto `protobuf:"bytes,2,opt,name=type,proto3" json:"type,omitempty"`
	// A human-readable documentation for this value. Markdown is allowed.
	DocString            string   `protobuf:"bytes,3,opt,name=doc_string,json=docString,proto3" json:"doc_string,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *ValueInfoProto) Reset()         { *m = ValueInfoProto{} }
func (m *ValueInfoProto) String() string { return proto.CompactTextString(m) }
func (*ValueInfoProto) ProtoMessage()    {}
func (*ValueInfoProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0206993eefcdc9e, []int{1}
}

func (m *ValueInfoProto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ValueInfoProto.Unmarshal(m, b)
}
func (m *ValueInfoProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ValueInfoProto.Marshal(b, m, deterministic)
}
func (m *ValueInfoProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ValueInfoProto.Merge(m, src)
}
func (m *ValueInfoProto) XXX_Size() int {
	return xxx_messageInfo_ValueInfoProto.Size(m)
}
func (m *ValueInfoProto) XXX_DiscardUnknown() {
	xxx_messageInfo_ValueInfoProto.DiscardUnknown(m)
}

var xxx_messageInfo_ValueInfoProto proto.InternalMessageInfo

func (m *ValueInfoProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *ValueInfoProto) GetType() *TypeProto {
	if m != nil {
		return m.Type
	}
	return nil
}

func (m *ValueInfoProto) GetDocString() string {
	if m != nil {
		return m.DocString
	}
	return ""
}

// Nodes
//
// Computation graphs are made up of a DAG of nodes, which represent what is
// commonly called a "layer" or "pipeline stage" in machine learning frameworks.
//
// For example, it can be a node of type "Conv" that takes in an image, a filter
// tensor and a bias tensor, and produces the convolved output.
type NodeProto struct {
	Input  []string `protobuf:"bytes,1,rep,name=input,proto3" json:"input,omitempty"`
	Output []string `protobuf:"bytes,2,rep,name=output,proto3" json:"output,omitempty"`
	// An optional identifier for this node in a graph.
	// This field MAY be absent in ths version of the IR.
	Name string `protobuf:"bytes,3,opt,name=name,proto3" json:"name,omitempty"`
	// The symbolic identifier of the Operator to execute.
	OpType string `protobuf:"bytes,4,opt,name=op_type,json=opType,proto3" json:"op_type,omitempty"`
	// The domain of the OperatorSet that specifies the operator named by op_type.
	Domain string `protobuf:"bytes,7,opt,name=domain,proto3" json:"domain,omitempty"`
	// Additional named attributes.
	Attribute []*AttributeProto `protobuf:"bytes,5,rep,name=attribute,proto3" json:"attribute,omitempty"`
	// A human-readable documentation for this node. Markdown is allowed.
	DocString            string   `protobuf:"bytes,6,opt,name=doc_string,json=docString,proto3" json:"doc_string,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *NodeProto) Reset()         { *m = NodeProto{} }
func (m *NodeProto) String() string { return proto.CompactTextString(m) }
func (*NodeProto) ProtoMessage()    {}
func (*NodeProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0206993eefcdc9e, []int{2}
}

func (m *NodeProto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_NodeProto.Unmarshal(m, b)
}
func (m *NodeProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_NodeProto.Marshal(b, m, deterministic)
}
func (m *NodeProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_NodeProto.Merge(m, src)
}
func (m *NodeProto) XXX_Size() int {
	return xxx_messageInfo_NodeProto.Size(m)
}
func (m *NodeProto) XXX_DiscardUnknown() {
	xxx_messageInfo_NodeProto.DiscardUnknown(m)
}

var xxx_messageInfo_NodeProto proto.InternalMessageInfo

func (m *NodeProto) GetInput() []string {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *NodeProto) GetOutput() []string {
	if m != nil {
		return m.Output
	}
	return nil
}

func (m *NodeProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *NodeProto) GetOpType() string {
	if m != nil {
		return m.OpType
	}
	return ""
}

func (m *NodeProto) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *NodeProto) GetAttribute() []*AttributeProto {
	if m != nil {
		return m.Attribute
	}
	return nil
}

func (m *NodeProto) GetDocString() string {
	if m != nil {
		return m.DocString
	}
	return ""
}

// Models
//
// ModelProto is a top-level file/container format for bundling a ML model and
// associating its computation graph with metadata.
//
// The semantics of the model are described by the associated GraphProto.
type ModelProto struct {
	// The version of the IR this model targets. See Version enum above.
	// This field MUST be present.
	IrVersion int64 `protobuf:"varint,1,opt,name=ir_version,json=irVersion,proto3" json:"ir_version,omitempty"`
	// The OperatorSets this model relies on.
	// All ModelProtos MUST have at least one entry that
	// specifies which version of the ONNX OperatorSet is
	// being imported.
	//
	// All nodes in the ModelProto's graph will bind against the operator
	// with the same-domain/same-op_type operator with the HIGHEST version
	// in the referenced operator sets.
	OpsetImport []*OperatorSetIdProto `protobuf:"bytes,8,rep,name=opset_import,json=opsetImport,proto3" json:"opset_import,omitempty"`
	// The name of the framework or tool used to generate this model.
	// This field SHOULD be present to indicate which implementation/tool/framework
	// emitted the model.
	ProducerName string `protobuf:"bytes,2,opt,name=producer_name,json=producerName,proto3" json:"producer_name,omitempty"`
	// The version of the framework or tool used to generate this model.
	// This field SHOULD be present to indicate which implementation/tool/framework
	// emitted the model.
	ProducerVersion string `protobuf:"bytes,3,opt,name=producer_version,json=producerVersion,proto3" json:"producer_version,omitempty"`
	// Domain name of the model.
	// We use reverse domain names as name space indicators. For example:
	// `com.facebook.fair` or `com.microsoft.cognitiveservices`
	//
	// Together with `model_version` and GraphProto.name, this forms the unique identity of
	// the graph.
	Domain string `protobuf:"bytes,4,opt,name=domain,proto3" json:"domain,omitempty"`
	// The version of the graph encoded. See Version enum below.
	ModelVersion int64 `protobuf:"varint,5,opt,name=model_version,json=modelVersion,proto3" json:"model_version,omitempty"`
	// A human-readable documentation for this model. Markdown is allowed.
	DocString string `protobuf:"bytes,6,opt,name=doc_string,json=docString,proto3" json:"doc_string,omitempty"`
	// The parameterized graph that is evaluated to execute the model.
	Graph *GraphProto `protobuf:"bytes,7,opt,name=graph,proto3" json:"graph,omitempty"`
	// Named metadata values; keys should be distinct.
	MetadataProps        []*StringStringEntryProto `protobuf:"bytes,14,rep,name=metadata_props,json=metadataProps,proto3" json:"metadata_props,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                  `json:"-"`
	XXX_unrecognized     []byte                    `json:"-"`
	XXX_sizecache        int32                     `json:"-"`
}

func (m *ModelProto) Reset()         { *m = ModelProto{} }
func (m *ModelProto) String() string { return proto.CompactTextString(m) }
func (*ModelProto) ProtoMessage()    {}
func (*ModelProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0206993eefcdc9e, []int{3}
}

func (m *ModelProto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_ModelProto.Unmarshal(m, b)
}
func (m *ModelProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_ModelProto.Marshal(b, m, deterministic)
}
func (m *ModelProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ModelProto.Merge(m, src)
}
func (m *ModelProto) XXX_Size() int {
	return xxx_messageInfo_ModelProto.Size(m)
}
func (m *ModelProto) XXX_DiscardUnknown() {
	xxx_messageInfo_ModelProto.DiscardUnknown(m)
}

var xxx_messageInfo_ModelProto proto.InternalMessageInfo

func (m *ModelProto) GetIrVersion() int64 {
	if m != nil {
		return m.IrVersion
	}
	return 0
}

func (m *ModelProto) GetOpsetImport() []*OperatorSetIdProto {
	if m != nil {
		return m.OpsetImport
	}
	return nil
}

func (m *ModelProto) GetProducerName() string {
	if m != nil {
		return m.ProducerName
	}
	return ""
}

func (m *ModelProto) GetProducerVersion() string {
	if m != nil {
		return m.ProducerVersion
	}
	return ""
}

func (m *ModelProto) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *ModelProto) GetModelVersion() int64 {
	if m != nil {
		return m.ModelVersion
	}
	return 0
}

func (m *ModelProto) GetDocString() string {
	if m != nil {
		return m.DocString
	}
	return ""
}

func (m *ModelProto) GetGraph() *GraphProto {
	if m != nil {
		return m.Graph
	}
	return nil
}

func (m *ModelProto) GetMetadataProps() []*StringStringEntryProto {
	if m != nil {
		return m.MetadataProps
	}
	return nil
}

// StringStringEntryProto follows the pattern for cross-proto-version maps.
// See https://developers.google.com/protocol-buffers/docs/proto3#maps
type StringStringEntryProto struct {
	Key                  string   `protobuf:"bytes,1,opt,name=key,proto3" json:"key,omitempty"`
	Value                string   `protobuf:"bytes,2,opt,name=value,proto3" json:"value,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *StringStringEntryProto) Reset()         { *m = StringStringEntryProto{} }
func (m *StringStringEntryProto) String() string { return proto.CompactTextString(m) }
func (*StringStringEntryProto) ProtoMessage()    {}
func (*StringStringEntryProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0206993eefcdc9e, []int{4}
}

func (m *StringStringEntryProto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_StringStringEntryProto.Unmarshal(m, b)
}
func (m *StringStringEntryProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_StringStringEntryProto.Marshal(b, m, deterministic)
}
func (m *StringStringEntryProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_StringStringEntryProto.Merge(m, src)
}
func (m *StringStringEntryProto) XXX_Size() int {
	return xxx_messageInfo_StringStringEntryProto.Size(m)
}
func (m *StringStringEntryProto) XXX_DiscardUnknown() {
	xxx_messageInfo_StringStringEntryProto.DiscardUnknown(m)
}

var xxx_messageInfo_StringStringEntryProto proto.InternalMessageInfo

func (m *StringStringEntryProto) GetKey() string {
	if m != nil {
		return m.Key
	}
	return ""
}

func (m *StringStringEntryProto) GetValue() string {
	if m != nil {
		return m.Value
	}
	return ""
}

// Graphs
//
// A graph defines the computational logic of a model and is comprised of a parameterized
// list of nodes that form a directed acyclic graph based on their inputs and outputs.
// This is the equivalent of the "network" or "graph" in many deep learning
// frameworks.
type GraphProto struct {
	// The nodes in the graph, sorted topologically.
	Node []*NodeProto `protobuf:"bytes,1,rep,name=node,proto3" json:"node,omitempty"`
	// The name of the graph.
	Name string `protobuf:"bytes,2,opt,name=name,proto3" json:"name,omitempty"`
	// A list of named tensor values, used to specify constant inputs of the graph.
	// Each TensorProto entry must have a distinct name (within the list) that
	// also appears in the input list.
	Initializer []*TensorProto `protobuf:"bytes,5,rep,name=initializer,proto3" json:"initializer,omitempty"`
	// A human-readable documentation for this graph. Markdown is allowed.
	DocString string `protobuf:"bytes,10,opt,name=doc_string,json=docString,proto3" json:"doc_string,omitempty"`
	// The inputs and outputs of the graph.
	Input  []*ValueInfoProto `protobuf:"bytes,11,rep,name=input,proto3" json:"input,omitempty"`
	Output []*ValueInfoProto `protobuf:"bytes,12,rep,name=output,proto3" json:"output,omitempty"`
	// Information for the values in the graph. The ValueInfoProto.name's
	// must be distinct. It is optional for a value to appear in value_info list.
	ValueInfo            []*ValueInfoProto `protobuf:"bytes,13,rep,name=value_info,json=valueInfo,proto3" json:"value_info,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *GraphProto) Reset()         { *m = GraphProto{} }
func (m *GraphProto) String() string { return proto.CompactTextString(m) }
func (*GraphProto) ProtoMessage()    {}
func (*GraphProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0206993eefcdc9e, []int{5}
}

func (m *GraphProto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GraphProto.Unmarshal(m, b)
}
func (m *GraphProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GraphProto.Marshal(b, m, deterministic)
}
func (m *GraphProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GraphProto.Merge(m, src)
}
func (m *GraphProto) XXX_Size() int {
	return xxx_messageInfo_GraphProto.Size(m)
}
func (m *GraphProto) XXX_DiscardUnknown() {
	xxx_messageInfo_GraphProto.DiscardUnknown(m)
}

var xxx_messageInfo_GraphProto proto.InternalMessageInfo

func (m *GraphProto) GetNode() []*NodeProto {
	if m != nil {
		return m.Node
	}
	return nil
}

func (m *GraphProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *GraphProto) GetInitializer() []*TensorProto {
	if m != nil {
		return m.Initializer
	}
	return nil
}

func (m *GraphProto) GetDocString() string {
	if m != nil {
		return m.DocString
	}
	return ""
}

func (m *GraphProto) GetInput() []*ValueInfoProto {
	if m != nil {
		return m.Input
	}
	return nil
}

func (m *GraphProto) GetOutput() []*ValueInfoProto {
	if m != nil {
		return m.Output
	}
	return nil
}

func (m *GraphProto) GetValueInfo() []*ValueInfoProto {
	if m != nil {
		return m.ValueInfo
	}
	return nil
}

// Tensors
//
// A serialized tensor value.
type TensorProto struct {
	// The shape of the tensor.
	Dims []int64 `protobuf:"varint,1,rep,packed,name=dims,proto3" json:"dims,omitempty"`
	// The data type of the tensor.
	// This field MUST have a valid TensorProto.DataType value
	DataType int32                `protobuf:"varint,2,opt,name=data_type,json=dataType,proto3" json:"data_type,omitempty"`
	Segment  *TensorProto_Segment `protobuf:"bytes,3,opt,name=segment,proto3" json:"segment,omitempty"`
	// For float and complex64 values
	// Complex64 tensors are encoded as a single array of floats,
	// with the real components appearing in odd numbered positions,
	// and the corresponding imaginary component apparing in the
	// subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
	// is encoded as [1.0, 2.0 ,3.0 ,4.0]
	// When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
	FloatData []float32 `protobuf:"fixed32,4,rep,packed,name=float_data,json=floatData,proto3" json:"float_data,omitempty"`
	// For int32, uint8, int8, uint16, int16, bool, and float16 values
	// float16 values must be bit-wise converted to an uint16_t prior
	// to writing to the buffer.
	// When this field is present, the data_type field MUST be
	// INT32, INT16, INT8, UINT16, UINT8, BOOL, or FLOAT16
	Int32Data []int32 `protobuf:"varint,5,rep,packed,name=int32_data,json=int32Data,proto3" json:"int32_data,omitempty"`
	// For strings.
	// Each element of string_data is a UTF-8 encoded Unicode
	// string. No trailing null, no leading BOM. The protobuf "string"
	// scalar type is not used to match ML community conventions.
	// When this field is present, the data_type field MUST be STRING
	StringData [][]byte `protobuf:"bytes,6,rep,name=string_data,json=stringData,proto3" json:"string_data,omitempty"`
	// For int64.
	// When this field is present, the data_type field MUST be INT64
	Int64Data []int64 `protobuf:"varint,7,rep,packed,name=int64_data,json=int64Data,proto3" json:"int64_data,omitempty"`
	// Optionally, a name for the tensor.
	Name string `protobuf:"bytes,8,opt,name=name,proto3" json:"name,omitempty"`
	// A human-readable documentation for this tensor. Markdown is allowed.
	DocString string `protobuf:"bytes,12,opt,name=doc_string,json=docString,proto3" json:"doc_string,omitempty"`
	// Serializations can either use one of the fields above, or use this
	// raw bytes field. The only exception is the string case, where one is
	// required to store the content in the repeated bytes string_data field.
	//
	// When this raw_data field is used to store tensor value, elements MUST
	// be stored in as fixed-width, little-endian order.
	// Floating-point data types MUST be stored in IEEE 754 format.
	// Complex64 elements must be written as two consecutive FLOAT values, real component first.
	// Complex128 elements must be written as two consecutive DOUBLE values, real component first.
	// Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
	//
	// Note: the advantage of specific field rather than the raw_data field is
	// that in some cases (e.g. int data), protobuf does a better packing via
	// variable length storage, and may lead to smaller binary footprint.
	// When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
	RawData []byte `protobuf:"bytes,9,opt,name=raw_data,json=rawData,proto3" json:"raw_data,omitempty"`
	// For double
	// Complex128 tensors are encoded as a single array of doubles,
	// with the real components appearing in odd numbered positions,
	// and the corresponding imaginary component apparing in the
	// subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
	// is encoded as [1.0, 2.0 ,3.0 ,4.0]
	// When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
	DoubleData []float64 `protobuf:"fixed64,10,rep,packed,name=double_data,json=doubleData,proto3" json:"double_data,omitempty"`
	// For uint64 and uint32 values
	// When this field is present, the data_type field MUST be
	// UINT32 or UINT64
	Uint64Data           []uint64 `protobuf:"varint,11,rep,packed,name=uint64_data,json=uint64Data,proto3" json:"uint64_data,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TensorProto) Reset()         { *m = TensorProto{} }
func (m *TensorProto) String() string { return proto.CompactTextString(m) }
func (*TensorProto) ProtoMessage()    {}
func (*TensorProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0206993eefcdc9e, []int{6}
}

func (m *TensorProto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TensorProto.Unmarshal(m, b)
}
func (m *TensorProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TensorProto.Marshal(b, m, deterministic)
}
func (m *TensorProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TensorProto.Merge(m, src)
}
func (m *TensorProto) XXX_Size() int {
	return xxx_messageInfo_TensorProto.Size(m)
}
func (m *TensorProto) XXX_DiscardUnknown() {
	xxx_messageInfo_TensorProto.DiscardUnknown(m)
}

var xxx_messageInfo_TensorProto proto.InternalMessageInfo

func (m *TensorProto) GetDims() []int64 {
	if m != nil {
		return m.Dims
	}
	return nil
}

func (m *TensorProto) GetDataType() int32 {
	if m != nil {
		return m.DataType
	}
	return 0
}

func (m *TensorProto) GetSegment() *TensorProto_Segment {
	if m != nil {
		return m.Segment
	}
	return nil
}

func (m *TensorProto) GetFloatData() []float32 {
	if m != nil {
		return m.FloatData
	}
	return nil
}

func (m *TensorProto) GetInt32Data() []int32 {
	if m != nil {
		return m.Int32Data
	}
	return nil
}

func (m *TensorProto) GetStringData() [][]byte {
	if m != nil {
		return m.StringData
	}
	return nil
}

func (m *TensorProto) GetInt64Data() []int64 {
	if m != nil {
		return m.Int64Data
	}
	return nil
}

func (m *TensorProto) GetName() string {
	if m != nil {
		return m.Name
	}
	return ""
}

func (m *TensorProto) GetDocString() string {
	if m != nil {
		return m.DocString
	}
	return ""
}

func (m *TensorProto) GetRawData() []byte {
	if m != nil {
		return m.RawData
	}
	return nil
}

func (m *TensorProto) GetDoubleData() []float64 {
	if m != nil {
		return m.DoubleData
	}
	return nil
}

func (m *TensorProto) GetUint64Data() []uint64 {
	if m != nil {
		return m.Uint64Data
	}
	return nil
}

// For very large tensors, we may want to store them in chunks, in which
// case the following fields will specify the segment that is stored in
// the current TensorProto.
type TensorProto_Segment struct {
	Begin                int64    `protobuf:"varint,1,opt,name=begin,proto3" json:"begin,omitempty"`
	End                  int64    `protobuf:"varint,2,opt,name=end,proto3" json:"end,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TensorProto_Segment) Reset()         { *m = TensorProto_Segment{} }
func (m *TensorProto_Segment) String() string { return proto.CompactTextString(m) }
func (*TensorProto_Segment) ProtoMessage()    {}
func (*TensorProto_Segment) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0206993eefcdc9e, []int{6, 0}
}

func (m *TensorProto_Segment) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TensorProto_Segment.Unmarshal(m, b)
}
func (m *TensorProto_Segment) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TensorProto_Segment.Marshal(b, m, deterministic)
}
func (m *TensorProto_Segment) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TensorProto_Segment.Merge(m, src)
}
func (m *TensorProto_Segment) XXX_Size() int {
	return xxx_messageInfo_TensorProto_Segment.Size(m)
}
func (m *TensorProto_Segment) XXX_DiscardUnknown() {
	xxx_messageInfo_TensorProto_Segment.DiscardUnknown(m)
}

var xxx_messageInfo_TensorProto_Segment proto.InternalMessageInfo

func (m *TensorProto_Segment) GetBegin() int64 {
	if m != nil {
		return m.Begin
	}
	return 0
}

func (m *TensorProto_Segment) GetEnd() int64 {
	if m != nil {
		return m.End
	}
	return 0
}

// Defines a tensor shape. A dimension can be either an integer value
// or a symbolic variable. A symbolic variable represents an unknown
// dimension.
type TensorShapeProto struct {
	Dim                  []*TensorShapeProto_Dimension `protobuf:"bytes,1,rep,name=dim,proto3" json:"dim,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                      `json:"-"`
	XXX_unrecognized     []byte                        `json:"-"`
	XXX_sizecache        int32                         `json:"-"`
}

func (m *TensorShapeProto) Reset()         { *m = TensorShapeProto{} }
func (m *TensorShapeProto) String() string { return proto.CompactTextString(m) }
func (*TensorShapeProto) ProtoMessage()    {}
func (*TensorShapeProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0206993eefcdc9e, []int{7}
}

func (m *TensorShapeProto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TensorShapeProto.Unmarshal(m, b)
}
func (m *TensorShapeProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TensorShapeProto.Marshal(b, m, deterministic)
}
func (m *TensorShapeProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TensorShapeProto.Merge(m, src)
}
func (m *TensorShapeProto) XXX_Size() int {
	return xxx_messageInfo_TensorShapeProto.Size(m)
}
func (m *TensorShapeProto) XXX_DiscardUnknown() {
	xxx_messageInfo_TensorShapeProto.DiscardUnknown(m)
}

var xxx_messageInfo_TensorShapeProto proto.InternalMessageInfo

func (m *TensorShapeProto) GetDim() []*TensorShapeProto_Dimension {
	if m != nil {
		return m.Dim
	}
	return nil
}

type TensorShapeProto_Dimension struct {
	// Types that are valid to be assigned to Value:
	//	*TensorShapeProto_Dimension_DimValue
	//	*TensorShapeProto_Dimension_DimParam
	Value isTensorShapeProto_Dimension_Value `protobuf_oneof:"value"`
	// Standard denotation can optionally be used to denote tensor
	// dimensions with standard semantic descriptions to ensure
	// that operations are applied to the correct axis of a tensor.
	// Refer to https://github.com/onnx/onnx/blob/master/docs/DimensionDenotation.md#denotation-definition
	// for pre-defined dimension denotations.
	Denotation           string   `protobuf:"bytes,3,opt,name=denotation,proto3" json:"denotation,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TensorShapeProto_Dimension) Reset()         { *m = TensorShapeProto_Dimension{} }
func (m *TensorShapeProto_Dimension) String() string { return proto.CompactTextString(m) }
func (*TensorShapeProto_Dimension) ProtoMessage()    {}
func (*TensorShapeProto_Dimension) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0206993eefcdc9e, []int{7, 0}
}

func (m *TensorShapeProto_Dimension) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TensorShapeProto_Dimension.Unmarshal(m, b)
}
func (m *TensorShapeProto_Dimension) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TensorShapeProto_Dimension.Marshal(b, m, deterministic)
}
func (m *TensorShapeProto_Dimension) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TensorShapeProto_Dimension.Merge(m, src)
}
func (m *TensorShapeProto_Dimension) XXX_Size() int {
	return xxx_messageInfo_TensorShapeProto_Dimension.Size(m)
}
func (m *TensorShapeProto_Dimension) XXX_DiscardUnknown() {
	xxx_messageInfo_TensorShapeProto_Dimension.DiscardUnknown(m)
}

var xxx_messageInfo_TensorShapeProto_Dimension proto.InternalMessageInfo

type isTensorShapeProto_Dimension_Value interface {
	isTensorShapeProto_Dimension_Value()
}

type TensorShapeProto_Dimension_DimValue struct {
	DimValue int64 `protobuf:"varint,1,opt,name=dim_value,json=dimValue,proto3,oneof"`
}

type TensorShapeProto_Dimension_DimParam struct {
	DimParam string `protobuf:"bytes,2,opt,name=dim_param,json=dimParam,proto3,oneof"`
}

func (*TensorShapeProto_Dimension_DimValue) isTensorShapeProto_Dimension_Value() {}

func (*TensorShapeProto_Dimension_DimParam) isTensorShapeProto_Dimension_Value() {}

func (m *TensorShapeProto_Dimension) GetValue() isTensorShapeProto_Dimension_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *TensorShapeProto_Dimension) GetDimValue() int64 {
	if x, ok := m.GetValue().(*TensorShapeProto_Dimension_DimValue); ok {
		return x.DimValue
	}
	return 0
}

func (m *TensorShapeProto_Dimension) GetDimParam() string {
	if x, ok := m.GetValue().(*TensorShapeProto_Dimension_DimParam); ok {
		return x.DimParam
	}
	return ""
}

func (m *TensorShapeProto_Dimension) GetDenotation() string {
	if m != nil {
		return m.Denotation
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TensorShapeProto_Dimension) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TensorShapeProto_Dimension_DimValue)(nil),
		(*TensorShapeProto_Dimension_DimParam)(nil),
	}
}

// Types
//
// The standard ONNX data types.
type TypeProto struct {
	// Types that are valid to be assigned to Value:
	//	*TypeProto_TensorType
	Value isTypeProto_Value `protobuf_oneof:"value"`
	// An optional denotation can be used to denote the whole
	// type with a standard semantic description as to what is
	// stored inside. Refer to https://github.com/onnx/onnx/blob/master/docs/TypeDenotation.md#type-denotation-definition
	// for pre-defined type denotations.
	Denotation           string   `protobuf:"bytes,6,opt,name=denotation,proto3" json:"denotation,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *TypeProto) Reset()         { *m = TypeProto{} }
func (m *TypeProto) String() string { return proto.CompactTextString(m) }
func (*TypeProto) ProtoMessage()    {}
func (*TypeProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0206993eefcdc9e, []int{8}
}

func (m *TypeProto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TypeProto.Unmarshal(m, b)
}
func (m *TypeProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TypeProto.Marshal(b, m, deterministic)
}
func (m *TypeProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TypeProto.Merge(m, src)
}
func (m *TypeProto) XXX_Size() int {
	return xxx_messageInfo_TypeProto.Size(m)
}
func (m *TypeProto) XXX_DiscardUnknown() {
	xxx_messageInfo_TypeProto.DiscardUnknown(m)
}

var xxx_messageInfo_TypeProto proto.InternalMessageInfo

type isTypeProto_Value interface {
	isTypeProto_Value()
}

type TypeProto_TensorType struct {
	TensorType *TypeProto_Tensor `protobuf:"bytes,1,opt,name=tensor_type,json=tensorType,proto3,oneof"`
}

func (*TypeProto_TensorType) isTypeProto_Value() {}

func (m *TypeProto) GetValue() isTypeProto_Value {
	if m != nil {
		return m.Value
	}
	return nil
}

func (m *TypeProto) GetTensorType() *TypeProto_Tensor {
	if x, ok := m.GetValue().(*TypeProto_TensorType); ok {
		return x.TensorType
	}
	return nil
}

func (m *TypeProto) GetDenotation() string {
	if m != nil {
		return m.Denotation
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*TypeProto) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*TypeProto_TensorType)(nil),
	}
}

type TypeProto_Tensor struct {
	// This field MUST NOT have the value of UNDEFINED
	// This field MUST have a valid TensorProto.DataType value
	// This field MUST be present for this version of the IR.
	ElemType             int32             `protobuf:"varint,1,opt,name=elem_type,json=elemType,proto3" json:"elem_type,omitempty"`
	Shape                *TensorShapeProto `protobuf:"bytes,2,opt,name=shape,proto3" json:"shape,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *TypeProto_Tensor) Reset()         { *m = TypeProto_Tensor{} }
func (m *TypeProto_Tensor) String() string { return proto.CompactTextString(m) }
func (*TypeProto_Tensor) ProtoMessage()    {}
func (*TypeProto_Tensor) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0206993eefcdc9e, []int{8, 0}
}

func (m *TypeProto_Tensor) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_TypeProto_Tensor.Unmarshal(m, b)
}
func (m *TypeProto_Tensor) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_TypeProto_Tensor.Marshal(b, m, deterministic)
}
func (m *TypeProto_Tensor) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TypeProto_Tensor.Merge(m, src)
}
func (m *TypeProto_Tensor) XXX_Size() int {
	return xxx_messageInfo_TypeProto_Tensor.Size(m)
}
func (m *TypeProto_Tensor) XXX_DiscardUnknown() {
	xxx_messageInfo_TypeProto_Tensor.DiscardUnknown(m)
}

var xxx_messageInfo_TypeProto_Tensor proto.InternalMessageInfo

func (m *TypeProto_Tensor) GetElemType() int32 {
	if m != nil {
		return m.ElemType
	}
	return 0
}

func (m *TypeProto_Tensor) GetShape() *TensorShapeProto {
	if m != nil {
		return m.Shape
	}
	return nil
}

// Operator Sets
//
// OperatorSets are uniquely identified by a (domain, opset_version) pair.
type OperatorSetIdProto struct {
	// The domain of the operator set being identified.
	// The empty string ("") or absence of this field implies the operator
	// set that is defined as part of the ONNX specification.
	// This field MUST be present in this version of the IR when referring to any other operator set.
	Domain string `protobuf:"bytes,1,opt,name=domain,proto3" json:"domain,omitempty"`
	// The version of the operator set being identified.
	// This field MUST be present in this version of the IR.
	Version              int64    `protobuf:"varint,2,opt,name=version,proto3" json:"version,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *OperatorSetIdProto) Reset()         { *m = OperatorSetIdProto{} }
func (m *OperatorSetIdProto) String() string { return proto.CompactTextString(m) }
func (*OperatorSetIdProto) ProtoMessage()    {}
func (*OperatorSetIdProto) Descriptor() ([]byte, []int) {
	return fileDescriptor_d0206993eefcdc9e, []int{9}
}

func (m *OperatorSetIdProto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_OperatorSetIdProto.Unmarshal(m, b)
}
func (m *OperatorSetIdProto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_OperatorSetIdProto.Marshal(b, m, deterministic)
}
func (m *OperatorSetIdProto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_OperatorSetIdProto.Merge(m, src)
}
func (m *OperatorSetIdProto) XXX_Size() int {
	return xxx_messageInfo_OperatorSetIdProto.Size(m)
}
func (m *OperatorSetIdProto) XXX_DiscardUnknown() {
	xxx_messageInfo_OperatorSetIdProto.DiscardUnknown(m)
}

var xxx_messageInfo_OperatorSetIdProto proto.InternalMessageInfo

func (m *OperatorSetIdProto) GetDomain() string {
	if m != nil {
		return m.Domain
	}
	return ""
}

func (m *OperatorSetIdProto) GetVersion() int64 {
	if m != nil {
		return m.Version
	}
	return 0
}

func init() {
	proto.RegisterEnum("onnx.Version", Version_name, Version_value)
	proto.RegisterEnum("onnx.AttributeProto_AttributeType", AttributeProto_AttributeType_name, AttributeProto_AttributeType_value)
	proto.RegisterEnum("onnx.TensorProto_DataType", TensorProto_DataType_name, TensorProto_DataType_value)
	proto.RegisterType((*AttributeProto)(nil), "onnx.AttributeProto")
	proto.RegisterType((*ValueInfoProto)(nil), "onnx.ValueInfoProto")
	proto.RegisterType((*NodeProto)(nil), "onnx.NodeProto")
	proto.RegisterType((*ModelProto)(nil), "onnx.ModelProto")
	proto.RegisterType((*StringStringEntryProto)(nil), "onnx.StringStringEntryProto")
	proto.RegisterType((*GraphProto)(nil), "onnx.GraphProto")
	proto.RegisterType((*TensorProto)(nil), "onnx.TensorProto")
	proto.RegisterType((*TensorProto_Segment)(nil), "onnx.TensorProto.Segment")
	proto.RegisterType((*TensorShapeProto)(nil), "onnx.TensorShapeProto")
	proto.RegisterType((*TensorShapeProto_Dimension)(nil), "onnx.TensorShapeProto.Dimension")
	proto.RegisterType((*TypeProto)(nil), "onnx.TypeProto")
	proto.RegisterType((*TypeProto_Tensor)(nil), "onnx.TypeProto.Tensor")
	proto.RegisterType((*OperatorSetIdProto)(nil), "onnx.OperatorSetIdProto")
}

func init() { proto.RegisterFile("onnx.proto3", fileDescriptor_d0206993eefcdc9e) }

var fileDescriptor_d0206993eefcdc9e = []byte{
	// 1327 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x7c, 0x56, 0xcd, 0x6e, 0xdb, 0x46,
	0x10, 0x36, 0x45, 0x51, 0x14, 0x87, 0x92, 0xb2, 0x5d, 0x24, 0x2e, 0x93, 0x36, 0x89, 0x2a, 0x03,
	0x85, 0x9a, 0x06, 0x86, 0x25, 0x19, 0x6a, 0x8a, 0x5e, 0x6a, 0xc7, 0x4a, 0x22, 0xc0, 0x91, 0x8c,
	0xa5, 0x12, 0xf4, 0x46, 0xd0, 0xe6, 0xca, 0x21, 0x6a, 0xfe, 0x80, 0x5c, 0x25, 0x75, 0x6f, 0x7d,
	0x84, 0x3e, 0x44, 0x81, 0x3e, 0x43, 0x7b, 0xed, 0x0b, 0xf4, 0xda, 0xa7, 0x29, 0x76, 0x96, 0xd4,
	0x5f, 0x1c, 0x5f, 0x84, 0x9d, 0x99, 0x6f, 0x86, 0xb3, 0x33, 0xdf, 0xec, 0x08, 0xec, 0x24, 0x8e,
	0x7f, 0xd9, 0x4f, 0xb3, 0x44, 0x24, 0x03, 0x5a, 0x95, 0x42, 0xe7, 0xef, 0x2a, 0xb4, 0x8e, 0x84,
	0xc8, 0xc2, 0xf3, 0x85, 0xe0, 0x67, 0xd2, 0x42, 0x29, 0x54, 0x63, 0x3f, 0xe2, 0x8e, 0xd6, 0xd6,
	0xba, 0x16, 0xc3, 0x33, 0xed, 0x40, 0x33, 0xe3, 0x73, 0xcf, 0x17, 0x22, 0xf3, 0xd0, 0x78, 0x0f,
	0x8d, 0x76, 0xc6, 0xe7, 0xd2, 0x7b, 0x22, 0x31, 0x0f, 0x01, 0x82, 0xe4, 0xc2, 0xcb, 0x45, 0x16,
	0xc6, 0x97, 0x4e, 0x13, 0x01, 0x56, 0x90, 0x5c, 0xb8, 0xa8, 0xa0, 0x43, 0xa8, 0x8a, 0xeb, 0x94,
	0x3b, 0x77, 0xdb, 0x5a, 0xb7, 0xd5, 0xef, 0xec, 0x63, 0x2e, 0x9b, 0x9f, 0x5e, 0x89, 0xb3, 0xeb,
	0x94, 0x33, 0xc4, 0xd3, 0x06, 0x68, 0x73, 0xa7, 0xd2, 0xd6, 0xba, 0x15, 0xa6, 0xcd, 0xa5, 0x14,
	0x3a, 0x7a, 0x5b, 0xeb, 0xea, 0x4c, 0x0b, 0xa5, 0x94, 0x3b, 0xd5, 0xb6, 0xd6, 0x6d, 0x30, 0x2d,
	0xa7, 0x8f, 0x41, 0x13, 0x8e, 0xd1, 0xd6, 0xba, 0x76, 0xff, 0x33, 0x15, 0x7e, 0xc6, 0xe3, 0x3c,
	0xc9, 0x30, 0x36, 0xd3, 0x04, 0x7d, 0x04, 0xda, 0xa5, 0x53, 0x43, 0x00, 0x51, 0x80, 0x97, 0x99,
	0x9f, 0xbe, 0x2b, 0xec, 0x97, 0x74, 0x17, 0x6a, 0xf3, 0xab, 0xc4, 0x17, 0xb9, 0x63, 0xb6, 0xf5,
	0x6e, 0x85, 0x15, 0x92, 0xac, 0x48, 0x18, 0x8b, 0xdc, 0xa9, 0xb7, 0xf5, 0xae, 0xce, 0xf0, 0x4c,
	0x1d, 0x30, 0xd5, 0x4d, 0x73, 0xc7, 0x6a, 0xeb, 0xdd, 0x06, 0x2b, 0x45, 0xfa, 0x2d, 0x98, 0x02,
	0xbf, 0x9b, 0x3b, 0xd0, 0xd6, 0x6f, 0x4e, 0xa6, 0x44, 0xd0, 0x2e, 0xd4, 0x2e, 0x65, 0x0e, 0xb9,
	0x63, 0x23, 0xf6, 0xe3, 0xbc, 0x0a, 0x7b, 0xe7, 0x77, 0x0d, 0x9a, 0x1b, 0xf5, 0xa1, 0x4d, 0xb0,
	0xde, 0x4c, 0x4e, 0x46, 0x2f, 0xc6, 0x93, 0xd1, 0x09, 0xd9, 0xa1, 0x16, 0x18, 0x2f, 0x4e, 0xa7,
	0x47, 0x33, 0xa2, 0x51, 0x13, 0xf4, 0xf1, 0x64, 0x46, 0x2a, 0x14, 0xa0, 0xe6, 0xce, 0xd8, 0x78,
	0xf2, 0x92, 0xe8, 0xf2, 0x3c, 0x1b, 0x4d, 0xdc, 0x29, 0x23, 0x55, 0x89, 0x7d, 0xc9, 0x8e, 0xce,
	0x5e, 0x11, 0x43, 0xaa, 0xd1, 0xcd, 0x25, 0x35, 0x5a, 0x87, 0xea, 0x78, 0x32, 0x73, 0x89, 0x49,
	0x6d, 0x30, 0x95, 0xa3, 0x4b, 0xea, 0x52, 0x50, 0x9e, 0x2e, 0xb1, 0x24, 0x1e, 0x5d, 0x5d, 0x02,
	0x9d, 0x77, 0xd0, 0x7a, 0xeb, 0x5f, 0x2d, 0xf8, 0x38, 0x9e, 0x27, 0x9f, 0x26, 0xcf, 0x5e, 0xd1,
	0xf9, 0x0a, 0x56, 0xfe, 0x4e, 0x51, 0x8d, 0xeb, 0x54, 0x35, 0xbd, 0x68, 0xf3, 0x26, 0x7b, 0xf4,
	0x2d, 0xf6, 0x74, 0xfe, 0xd5, 0xc0, 0x9a, 0x24, 0x41, 0x41, 0xd1, 0xbb, 0x60, 0x84, 0x71, 0xba,
	0x10, 0x8e, 0xd6, 0xd6, 0xbb, 0x16, 0x53, 0x82, 0x6c, 0x5f, 0xb2, 0x10, 0x52, 0x5d, 0x41, 0x75,
	0x21, 0x2d, 0x73, 0xd2, 0xd7, 0x72, 0xfa, 0x1c, 0xcc, 0x24, 0xf5, 0x30, 0xad, 0x2a, 0xaa, 0x6b,
	0x49, 0x8a, 0x45, 0xdd, 0x85, 0x5a, 0x90, 0x44, 0x7e, 0x18, 0x3b, 0xa6, 0xd2, 0x2b, 0x89, 0xf6,
	0xc1, 0xf2, 0xcb, 0xea, 0x3b, 0x06, 0xf6, 0xea, 0xee, 0x4d, 0x1c, 0x66, 0x2b, 0xd8, 0xd6, 0x9d,
	0x6a, 0xdb, 0x77, 0xfa, 0x4d, 0x07, 0x78, 0x9d, 0x04, 0xfc, 0x4a, 0x5d, 0xea, 0x21, 0x40, 0x98,
	0x79, 0xef, 0x79, 0x96, 0x87, 0x49, 0x8c, 0x05, 0xd4, 0x99, 0x15, 0x66, 0x6f, 0x95, 0x82, 0xfe,
	0x00, 0x8d, 0x24, 0xcd, 0xb9, 0xf0, 0xc2, 0x28, 0x4d, 0x32, 0x81, 0x64, 0xb4, 0xfb, 0x8e, 0xca,
	0x61, 0x9a, 0xf2, 0xcc, 0x17, 0x49, 0xe6, 0x72, 0x31, 0x0e, 0x54, 0x1e, 0x36, 0xa2, 0xc7, 0x08,
	0xa6, 0x7b, 0xd0, 0x4c, 0xb3, 0x24, 0x58, 0x5c, 0xf0, 0x62, 0x7e, 0x2b, 0x98, 0x4c, 0xa3, 0x54,
	0xe2, 0x00, 0x7f, 0x03, 0x64, 0x09, 0x2a, 0xd3, 0x50, 0x35, 0xbb, 0x53, 0xea, 0xcb, 0x64, 0x56,
	0x55, 0xaa, 0x6e, 0x54, 0x69, 0x0f, 0x9a, 0x91, 0xbc, 0xd1, 0xd2, 0xdf, 0xc0, 0x6b, 0x34, 0x50,
	0x59, 0x3a, 0xdf, 0x5e, 0x16, 0xfa, 0x35, 0x18, 0x48, 0x79, 0x6c, 0xc0, 0x4d, 0x13, 0xa1, 0xcc,
	0xf4, 0x39, 0xb4, 0x22, 0x2e, 0xfc, 0xc0, 0x17, 0xbe, 0x97, 0x66, 0x49, 0x9a, 0x3b, 0x2d, 0x2c,
	0xc9, 0x97, 0xca, 0x41, 0x45, 0x53, 0xbf, 0xa3, 0x58, 0x64, 0xd7, 0xca, 0xb9, 0x59, 0xfa, 0x9c,
	0x49, 0x97, 0xce, 0x8f, 0xb0, 0x7b, 0x33, 0x90, 0x12, 0xd0, 0x7f, 0xe6, 0xd7, 0x05, 0x91, 0xe5,
	0x51, 0xb2, 0xee, 0xbd, 0x64, 0x7b, 0x51, 0x3c, 0x25, 0x74, 0xfe, 0xac, 0x00, 0xac, 0x92, 0x93,
	0x64, 0x8f, 0x93, 0x80, 0x23, 0x33, 0x97, 0x64, 0x5f, 0x32, 0x97, 0xa1, 0x71, 0xc9, 0xc8, 0xca,
	0x1a, 0x23, 0x07, 0x60, 0x87, 0x71, 0x28, 0x42, 0xff, 0x2a, 0xfc, 0x95, 0x67, 0x05, 0xc5, 0x6e,
	0x78, 0x3a, 0xd6, 0x51, 0x5b, 0xa5, 0x84, 0xed, 0x52, 0x3e, 0x29, 0xe7, 0xc4, 0x5e, 0x27, 0xec,
	0xe6, 0xc8, 0x96, 0xd3, 0xf3, 0x74, 0x39, 0x3d, 0x8d, 0x5b, 0xc0, 0xe5, 0x4c, 0x0d, 0x00, 0xf0,
	0xfa, 0x5e, 0x18, 0xcf, 0x13, 0xa7, 0x79, 0x8b, 0x87, 0xf5, 0xbe, 0x94, 0x3b, 0x7f, 0x18, 0x60,
	0xaf, 0x5d, 0x45, 0x96, 0x21, 0x08, 0xa3, 0x1c, 0x6b, 0xa5, 0x33, 0x3c, 0xd3, 0x2f, 0xc0, 0xc2,
	0x8e, 0x2e, 0x5f, 0x0c, 0x83, 0xd5, 0xa5, 0x02, 0x87, 0x73, 0x00, 0x66, 0xce, 0x2f, 0x23, 0x1e,
	0x0b, 0x24, 0xa6, 0xdd, 0xbf, 0xff, 0x51, 0x7d, 0xf6, 0x5d, 0x05, 0x60, 0x25, 0x92, 0x7e, 0x05,
	0x80, 0xef, 0xb8, 0x27, 0xc3, 0x38, 0x55, 0xf9, 0xb2, 0x1f, 0x57, 0x88, 0xc6, 0x2c, 0xd4, 0x9e,
	0xf8, 0xc2, 0x97, 0x90, 0x30, 0x16, 0x83, 0xbe, 0x82, 0xc8, 0xd2, 0x1b, 0x0a, 0x82, 0x5a, 0x84,
	0x3c, 0x06, 0x5b, 0x55, 0x59, 0x61, 0x6a, 0xf8, 0xe6, 0x83, 0x52, 0xad, 0xc5, 0x18, 0x1e, 0x2a,
	0xbb, 0x5c, 0x20, 0xfa, 0x32, 0xc6, 0xf0, 0x10, 0x21, 0x65, 0xdb, 0xeb, 0x6b, 0x6d, 0xdf, 0xec,
	0x60, 0x63, 0xbb, 0x83, 0xf7, 0xa1, 0x9e, 0xf9, 0x1f, 0x54, 0x4c, 0x0b, 0x17, 0x9d, 0x99, 0xf9,
	0x1f, 0x30, 0xda, 0x1e, 0xd8, 0x41, 0xb2, 0x38, 0xbf, 0xe2, 0xca, 0x2a, 0x77, 0x8d, 0x86, 0x5f,
	0x04, 0xa5, 0x2e, 0x41, 0x8b, 0xb5, 0xb4, 0x24, 0x0f, 0xaa, 0x0a, 0xb4, 0x58, 0xe6, 0xf5, 0xa0,
	0x07, 0x66, 0x51, 0x35, 0xc9, 0xf1, 0x73, 0x7e, 0x19, 0x96, 0xef, 0x8f, 0x12, 0xe4, 0x2c, 0xf0,
	0x38, 0xc0, 0x76, 0xe8, 0x4c, 0x1e, 0x3b, 0xff, 0x69, 0x50, 0x3f, 0x29, 0xdb, 0xf2, 0xe9, 0x45,
	0x64, 0x81, 0xf1, 0x66, 0x3c, 0x99, 0x3d, 0x23, 0x95, 0x62, 0xb7, 0x3c, 0x53, 0x8b, 0x48, 0x2a,
	0x7b, 0x43, 0xb5, 0x88, 0xd4, 0xd1, 0x28, 0x8e, 0x83, 0x3e, 0xa9, 0x15, 0xc7, 0xe1, 0x21, 0x31,
	0xd7, 0x36, 0x58, 0x5d, 0x86, 0x38, 0x9e, 0x4e, 0x4f, 0x89, 0x25, 0x37, 0x12, 0x7e, 0xa2, 0x37,
	0x24, 0x20, 0x21, 0x27, 0xd3, 0x37, 0xc7, 0xa7, 0x23, 0x62, 0x97, 0xb1, 0x07, 0x7d, 0xd2, 0x28,
	0xcf, 0xc3, 0x43, 0xd2, 0x94, 0x29, 0x3e, 0x9f, 0xbe, 0x3e, 0x3b, 0x1d, 0xfd, 0x34, 0x3c, 0x24,
	0x2d, 0xda, 0x02, 0x28, 0xc4, 0x5e, 0xff, 0x19, 0xb9, 0x43, 0x1b, 0x50, 0x3f, 0x2e, 0x03, 0x92,
	0xce, 0x5f, 0x1a, 0x10, 0x45, 0x29, 0xf7, 0x9d, 0x5f, 0xac, 0x29, 0xda, 0x07, 0x3d, 0x08, 0xa3,
	0x62, 0xae, 0xdb, 0xeb, 0xbc, 0x5b, 0x81, 0xf6, 0x4f, 0xc2, 0x88, 0xc7, 0xf2, 0x91, 0x63, 0x12,
	0xfc, 0x20, 0x03, 0x6b, 0xa9, 0xa1, 0x0f, 0xc1, 0x0a, 0xc2, 0xc8, 0x53, 0x4f, 0x08, 0x96, 0xf7,
	0xd5, 0x0e, 0xab, 0x07, 0x61, 0x84, 0x03, 0x53, 0x9a, 0x53, 0x3f, 0xf3, 0x23, 0xf5, 0x30, 0x14,
	0xe6, 0x33, 0xa9, 0xa1, 0x8f, 0x00, 0x02, 0x1e, 0x27, 0xc2, 0x17, 0xab, 0x67, 0x79, 0x4d, 0x73,
	0x6c, 0x16, 0x8f, 0x53, 0xe7, 0x1f, 0x0d, 0xac, 0xe5, 0x72, 0xa5, 0xdf, 0x83, 0xad, 0xfe, 0x6a,
	0xa8, 0x81, 0xd2, 0x70, 0x6a, 0x76, 0xb7, 0x56, 0x70, 0x71, 0x8f, 0x57, 0x3b, 0x0c, 0x14, 0x18,
	0xbb, 0xba, 0xf9, 0xc5, 0xda, 0xf6, 0x17, 0x1f, 0xb8, 0x50, 0x53, 0x7e, 0x72, 0x66, 0xf9, 0x15,
	0x8f, 0x56, 0x9f, 0x30, 0x58, 0x5d, 0x2a, 0x30, 0xcc, 0x53, 0x30, 0x72, 0x59, 0xa0, 0x62, 0xfd,
	0xef, 0xde, 0x5c, 0x39, 0xa6, 0x40, 0xab, 0x6b, 0xbc, 0x00, 0xfa, 0xf1, 0x52, 0x5b, 0xdb, 0x3b,
	0xda, 0xc6, 0xde, 0x71, 0xc0, 0x2c, 0x37, 0x8e, 0x22, 0x69, 0x29, 0x3e, 0xb9, 0x00, 0xb3, 0xdc,
	0x3b, 0x14, 0x5a, 0x9e, 0x3b, 0x3b, 0x62, 0x33, 0xef, 0xed, 0x88, 0xb9, 0xe3, 0xe9, 0x84, 0xec,
	0xd0, 0xfb, 0x70, 0x6f, 0xcc, 0x4a, 0xd9, 0xeb, 0x1f, 0xf4, 0xbe, 0xf3, 0x7a, 0x07, 0x5e, 0xef,
	0x80, 0x68, 0x9f, 0x30, 0x0d, 0x0e, 0x48, 0x45, 0xd2, 0x67, 0x65, 0x22, 0xfa, 0x79, 0x4d, 0xfd,
	0xa7, 0xfe, 0x3f, 0x00, 0x00, 0xff, 0xff, 0xe5, 0x94, 0x6a, 0xc8, 0x61, 0x0b, 0x00, 0x00,
}
